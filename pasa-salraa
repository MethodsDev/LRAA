#!/usr/bin/env python
# encoding: utf-8

import sys, os, re
import pysam
import argparse
import subprocess

sys.path.insert(0, os.path.sep.join([os.path.dirname(os.path.realpath(__file__)), "pylib"]))
from Splice_graph import Splice_graph
from PASA_SALRAA import PASA_SALRAA
from Transcript import Transcript
import Util_funcs
import PASA_SALRAA_Globals
import MultiProcessManager as mpm

import logging
#FORMAT = "%(asctime)-15s %(levelname)s %(module)s.%(name)s.%(funcName)s at %(lineno)d :\n\t%(message)s\n"
FORMAT = "%(asctime)-15s %(levelname)s %(module)s.%(name)s.%(funcName)s:\n\t%(message)s\n"

logger = logging.getLogger()
logging.basicConfig(format=FORMAT, level=logging.INFO)

READ_ALN_GAP_MERGE = 10


def main():

    parser = argparse.ArgumentParser(description="pasa-salraa: short and long read alignment assembler",
                                     formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument("--bam", type=str, required=True, help="target bam file")
    parser.add_argument("--genome", type=str, required=True, help="target genome file")

    parser.add_argument("--outputfile", type=str, default="pasa-salraa.gtf", help="output filename")

    parser.add_argument("--single_best_only", action='store_true', default=False,
                        help="only report the single highest scoring isoform per component")

    parser.add_argument("--CPU", type=int, default=1,
                        help="number of cores for multithreading")
    
    parser.add_argument("--debug", "-d", action='store_true', default=False,
                        help='debug mode, more verbose')

    parser.add_argument("--mpm_monitor", action='store_true', default=False)

    parser.add_argument("--no_allow_spacers", action='store_true', default=False)
    
    args = parser.parse_args()
    
    genome_fasta_filename = args.genome
    bam_filename = args.bam
    output_filename = args.outputfile
    single_best_only = args.single_best_only
    CPU = args.CPU

    if args.mpm_monitor:
        mpm.set_debug()

    
    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)
        PASA_SALRAA_Globals.DEBUG = True


    allow_spacers = not args.no_allow_spacers
        
    run_pasa_salraa(genome_fasta_filename,
                    bam_filename,
                    output_filename,
                    READ_ALN_GAP_MERGE,
                    single_best_only,
                    CPU,
                    allow_spacers)
    
    
    sys.exit(0)




def run_pasa_salraa(genome_fasta_filename, bam_file, output_filename,
                    read_aln_gap_merge,
                    single_best_only,
                    CPU,
                    allow_spacers):

    # data structures want:
    # ultimately exons and introns
    # build from reads.
    # define coverage intervals and introns as graph components.

    ofh = open(output_filename, 'wt')
    
    genome_contigs_list = get_genome_contigs_listing(genome_fasta_filename)

    prereconstruct_info_dir = "__prereconstruct"
    if not os.path.exists(prereconstruct_info_dir):
        os.makedirs(prereconstruct_info_dir)
        
    
    for contig_acc in genome_contigs_list:

        logger.info(f"-processing contig: {contig_acc}")
        
        sg = Splice_graph()
        sg.set_read_aln_gap_merge(read_aln_gap_merge)
        contig_seq_str = Util_funcs.retrieve_contig_seq_from_fasta_file(contig_acc, genome_fasta_filename)
        sg.build_splice_graph_for_contig(contig_acc, contig_seq_str, bam_file)

        if sg.is_empty():
            logger.info(f"-no splice graph created for contig: {contig_acc}.... skipping.")
            continue

        
        sg.write_intron_exon_splice_graph_bed_files("{}/prereconstruct.{}.pad1".format(prereconstruct_info_dir, contig_acc), pad=1)
        
        pasa_salraa_obj = PASA_SALRAA(sg, CPU)
        pasa_salraa_obj.build_multipath_graph(contig_acc, contig_seq_str, bam_file, allow_spacers)
        transcripts = pasa_salraa_obj.reconstruct_isoforms(single_best_only)

        logger.info("writing gtf output for {} containing {} transcripts".format(contig_acc, len(transcripts)))
        for transcript in transcripts:
            ofh.write(transcript.to_GTF_format() + "\n")


    ofh.close()
    
    return
    

def get_genome_contigs_listing(genome_fasta_filename):

    fai_file = "{}.fai".format(genome_fasta_filename)
    if not os.path.exists(fai_file):
        subprocess.check_call("samtools faidx {}".format(genome_fasta_filename),
                              shell=True)

    contigs_list = list()
    
    with open(fai_file) as fh:
        for line in fh:
            vals = line.split("\t")
            contig_acc = vals[0]
            contigs_list.append(contig_acc)

    return contigs_list
    
            
if __name__ == '__main__':
    main()
